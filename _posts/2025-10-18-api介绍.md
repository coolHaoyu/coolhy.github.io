# **`endpoint`**

`endpoint`用于唯一标识一个网络连接的一端（客户端或服务器），它包含：

- **IP地址**（IPv4 或 IPv6）
- **端口号**（Port）

## **服务器端**

服务器使用 `endpoint`来**绑定（bind）**并**监听（listen）**某个端口：

```c++
// 服务器监听 0.0.0.0:10086（IPv4，端口10086）
tcp::endpoint server_endpoint(tcp::v4(), 10086);
tcp::acceptor acceptor(io_context, server_endpoint);
```

这里 `server_endpoint`告诉操作系统：“请让我在 `10086`端口上接收连接”。

在服务器端，服务器可以通过 `remote_endpoint()`获取客户端的地址信息：

```c++
tcp::endpoint client_ep = sock->remote_endpoint();
std::cout << "Client connected from: " 
          << client_ep.address().to_string() << ":"
          << client_ep.port() << std::endl;
```

**服务器监听地址：**

指定服务器**监听哪些网络接口**（网卡）和端口。

```c++
tcp::acceptor a(ioc, tcp::endpoint(tcp::v4(), 10086));
tcp::endpoint listen_ep = a.local_endpoint();
std::cout << "Listening on: " << listen_ep.address() << ":" << listen_ep.port();
```

- 通常绑定到 `0.0.0.0`（IPv4）或 `::`（IPv6），表示监听**所有可用网卡**。
- 如果绑定到具体 IP（如 `127.0.0.1`），则只接受该接口的连接。
- **本质**：是服务器程序启动时主动绑定的地址。

**服务器实际地址：**

客户端**真正连接的服务器地址**（可能是公网IP、局域网IP或本地回环地址）。

通过客户端代码中的 `remote_endpoint()`获取：

```c++
tcp::endpoint server_ep = sock.remote_endpoint();
std::cout << "Connected to server: " << server_ep.address() << ":" << server_ep.port();
```

或在服务器端通过反向解析获取本机具体 IP：

```c++
auto endpoints = boost::asio::ip::tcp::resolver(ioc).resolve(boost::asio::ip::host_name(), "");
for (auto& ep : endpoints) {
    std::cout << "Server IP: " << ep.endpoint().address() << std::endl;
}
```

- 取决于服务器的**物理网络环境**（如多网卡、NAT、公网映射）。
- **本质**：是客户端实际使用的连接地址。

**关键区别**

| **对比项**   | **监听地址 (`acceptor.local_endpoint()`)** | **服务器的实际地址**                |
| :----------- | :----------------------------------------- | :---------------------------------- |
| **作用**     | 指定服务器监听哪些接口                     | 客户端真正连接的地址                |
| **典型值**   | `0.0.0.0:端口`（监听所有网卡）             | `192.168.1.100:端口`（具体IP）      |
| **绑定方式** | 由 `tcp::acceptor`在代码中显式绑定         | 由网络环境（网卡、路由器、DNS）决定 |
| **获取方法** | `acceptor.local_endpoint()`                | 客户端用 `socket.remote_endpoint()` |
| **修改影响** | 修改后需重启服务器                         | 动态变化（如切换网络、公网IP变化）  |

## **客户端**

客户端使用 `endpoint`来**指定要连接的服务器地址**：

```c++
// 客户端连接 127.0.0.1:10086（本机服务器）
tcp::endpoint server_endpoint(make_address("127.0.0.1"), 10086);
tcp::socket socket(io_context);
socket.connect(server_endpoint);
```

这里 `server_endpoint`告诉客户端：“请连接到 `127.0.0.1`的 `10086`端口”。

客户端地址可以在客户端代码中，可以通过 `local_endpoint()`获取：

```c++
tcp::socket sock(ioc);
sock.connect(server_endpoint); // 连接服务器

// 获取客户端实际使用的 IP 和端口
tcp::endpoint local_ep = sock.local_endpoint();
std::cout << "Client IP: " << local_ep.address().to_string() << "\n"
          << "Client Port: " << local_ep.port() << std::endl;
```

## 对比

| 角色       | 代码示例                            | 作用                       |
| :--------- | :---------------------------------- | :------------------------- |
| **服务器** | `tcp::endpoint(tcp::v4(), 10086)`   | 监听所有网卡的 `10086`端口 |
| **客户端** | `tcp::endpoint("127.0.0.1", 10086)` | 连接指定的服务器地址和端口 |

- **服务器**：用 `tcp::v4()`表示监听所有网卡（`0.0.0.0`）。
- **客户端**：必须明确指定服务器的 IP（如 `127.0.0.1`或公网 IP）。

# acceptor

```c++
tcp::acceptor a(ioc, tcp::endpoint(tcp::v4(), port));
```

作用是让服务器**监听指定端口**，等待客户端连接。

**`tcp::endpoint(tcp::v4(), port)`**

定义服务器监听的网络地址：

- **`tcp::v4()`**：监听 IPv4 地址（如果想支持 IPv6，用 `tcp::v6()`）。
- **`port`**：监听的端口号（如 `10086`）。



