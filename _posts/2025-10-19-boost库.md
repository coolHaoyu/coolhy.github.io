# 同步读写demo

学习了了boost::asio同步读写的api函数，现在将前面的api串联起来，做一个能跑起来的客户端和服务器。
客户端和服务器采用阻塞的同步读写方式完成通信。

## 客户端设计

客户端设计基本思路是根据服务器对端的ip和端口创建一个endpoint，然后创建socket连接这个endpoint，之后就可以用同步读写的方式发送和接收数据了。

```c++
#include<iostream>
#include<boost/asio.hpp>

using namespace std;
using namespace boost::asio::ip;

const int MAX_LENGTH = 1024;  // 定义最大消息长度

int main()
{
    try
    {
        // 创建IO上下文
        boost::asio::io_context ioc;

        // 定义服务器端点（IP和端口）
        tcp::endpoint remote_ep(make_address("127.0.0.1"), 10086);

        // 创建socket对象
        tcp::socket sock(ioc, remote_ep.protocol());

        // 尝试连接服务器
        boost::system::error_code error = boost::asio::error::host_not_found;
        sock.connect(remote_ep, error);

        // 检查连接是否成功
        if (error)
        {
            cout << "connect failed, code is " << error.value() << " error msg is " << error.message();
            return 0;
        }

        // 获取用户输入的消息
        std::cout << "Enter message: ";
        char request[MAX_LENGTH];
        std::cin.getline(request, MAX_LENGTH);

        // 发送消息到服务器
        size_t request_length = strlen(request);
        boost::asio::write(sock, boost::asio::buffer(request, request_length));

        // 接收服务器回复
        char reply[MAX_LENGTH];
        size_t reply_length = boost::asio::read(sock, boost::asio::buffer(reply, request_length));

        // 输出服务器回复
        std::cout << "Reply is: ";
        std::cout.write(reply, reply_length);
        std::cout << endl;
    }
    catch (std::exception& e)  // 捕获并处理异常
    {
        std::cerr << "Exception: " << e.what() << endl;
    }

    return 0;
}
```

## 服务器设计

### session函数

创建session函数，该函数为服务器处理客户端请求，每当我们获取客户端连接后就调用该函数。在session函数里里进行echo方式的读写，所谓echo就是应答式的处理。

```c++
void session(socket_ptr sock)
{
    try
    {
        for (;;)  // 持续处理客户端请求
        {
            char data[MAX_LENGTH];
            memset(data, '\0', MAX_LENGTH);  // 清空缓冲区

            // 读取客户端数据
            boost::system::error_code error;
            size_t length = sock->read_some(boost::asio::buffer(data, MAX_LENGTH), error);

            // 检查连接是否关闭
            if (error == boost::asio::error::eof)
            {
                std::cout << "connection closed by peer" << endl;
                break;
            }
            else if (error)  // 检查其他错误
            {
                throw boost::system::system_error(error);
            }

            // 打印接收到的消息
            cout << "receive from " << sock->remote_endpoint().address().to_string() << endl;
            cout << "receive message is " << data << endl;

            // 将消息回传给客户端
            boost::asio::write(*sock, boost::asio::buffer(data, MAX_LENGTH));
        }
    }
    catch (std::exception& e)  // 捕获并处理异常
    {
        std::cerr << "Exception in thread: " << e.what() << "\n" << std::endl;
    }
}
```

### server函数

server函数根据服务器ip和端口创建服务器acceptor用来接收数据，用socket接收新的连接，然后为这个socket创建session。

```c++
void server(boost::asio::io_context& ioc, unsigned short port)
{
    // 创建acceptor监听指定端口
    tcp::acceptor a(ioc, tcp::endpoint(tcp::v4(), port));
    for (;;)  // 持续接受新连接
    {
        socket_ptr sock(new tcp::socket(ioc));  // 创建新socket
        a.accept(*sock);  // 等待客户端连接

        // 为新连接创建线程处理
        auto t = std::make_shared<std::thread>(session, sock);
        /*
            避免线程泄漏：如果不存储线程指针，线程可能会在后台运行，但程序无法控制它们（例如无法正确 join或 detach）。
            确保安全退出：在 main()函数结束时，需要等待所有线程完成（join），否则程序可能会在子线程仍在运行时退出，导致未定义行为。
        */
        thread_set.insert(t);  // 将线程指针存入集合
    }
}
```

创建线程调用session函数可以分配独立的线程用于socket的读写，保证acceptor不会因为socket的读写而阻塞。

### 服务器代码

```c++
#include<iostream>
#include<boost/asio.hpp>
#include<set>
#include<memory>

using namespace std;
using namespace boost::asio::ip;

const int MAX_LENGTH = 1024;  // 定义最大消息长度

typedef shared_ptr<tcp::socket> socket_ptr;  // 定义socket智能指针类型
std::set<std::shared_ptr<std::thread>> thread_set;  // 存储线程指针的集合

// 处理客户端会话的函数
void session(socket_ptr sock)
{
    try
    {
        for (;;)  // 持续处理客户端请求
        {
            char data[MAX_LENGTH];
            memset(data, '\0', MAX_LENGTH);  // 清空缓冲区

            // 读取客户端数据
            boost::system::error_code error;
            size_t length = sock->read_some(boost::asio::buffer(data, MAX_LENGTH), error);

            // 检查连接是否关闭
            if (error == boost::asio::error::eof)
            {
                std::cout << "connection closed by peer" << endl;
                break;
            }
            else if (error)  // 检查其他错误
            {
                throw boost::system::system_error(error);
            }

            // 打印接收到的消息
            cout << "receive from " << sock->remote_endpoint().address().to_string() << endl;
            cout << "receive message is " << data << endl;

            // 将消息回传给客户端
            boost::asio::write(*sock, boost::asio::buffer(data, MAX_LENGTH));
        }
    }
    catch (std::exception& e)  // 捕获并处理异常
    {
        std::cerr << "Exception in thread: " << e.what() << "\n" << std::endl;
    }
}

// 服务器主函数
void server(boost::asio::io_context& ioc, unsigned short port)
{
    // 创建acceptor监听指定端口
    tcp::acceptor a(ioc, tcp::endpoint(tcp::v4(), port));
    for (;;)  // 持续接受新连接
    {
        socket_ptr sock(new tcp::socket(ioc));  // 创建新socket
        a.accept(*sock);  // 等待客户端连接

        // 为新连接创建线程处理
        auto t = std::make_shared<std::thread>(session, sock);
        /*
            避免线程泄漏：如果不存储线程指针，线程可能会在后台运行，但程序无法控制它们（例如无法正确 join或 detach）。
            确保安全退出：在 main()函数结束时，需要等待所有线程完成（join），否则程序可能会在子线程仍在运行时退出，导致未定义行为。
        */
        thread_set.insert(t);  // 将线程指针存入集合
    }
}

int main()
{
    try
    {
        boost::asio::io_context ioc;  // 创建IO上下文
        server(ioc, 10086);  // 启动服务器

        // 等待所有线程结束
        for (auto& t : thread_set)
        {
            t->join();
        }
    }
    catch (std::exception& e)  // 捕获并处理异常
    {
        std::cerr << "Exception: " << e.what() << std::endl;
    }
}
```

## 同步读写的优劣

1 同步读写的缺陷在于读写是阻塞的，如果客户端对端不发送数据服务器的read操作是阻塞的，这将导致服务器处于阻塞等待状态。

2 可以通过开辟新的线程为新生成的连接处理读写，但是一个进程开辟的线程是有限的，约为2048个线程，在Linux环境可以通过unlimit增加一个进程开辟的线程数，但是线程过多也会导致切换消耗的时间片较多。

3 该服务器和客户端为应答式，实际场景为全双工通信模式，发送和接收要独立分开。

4 该服务器和客户端未考虑粘包处理。

综上所述，是我们这个服务器和客户端存在的问题，为解决上述问题，我们在接下里的文章里做不断完善和改进，主要以异步读写改进上述方案。

当然同步读写的方式也有其优点，比如客户端连接数不多，而且服务器并发性不高的场景，可以使用同步读写的方式。使用同步读写能简化编码难度。