# 粘包处理

`void CSession::HandleRead(const boost::system::error_code& error, size_t  bytes_transferred, std::shared_ptr<CSession> shared_self)`函数。

这段代码的核心是**处理网络数据的分包和粘包问题**，确保正确解析消息头部（长度字段）和消息体。

##  1.**关键变量说明**

| 变量名              | 作用                                                         |
| :------------------ | :----------------------------------------------------------- |
| `bytes_transferred` | 本次 `async_read_some`实际读取到的数据长度（字节数）。       |
| `copy_len`          | 已从 `_data`缓冲区复制到消息节点的数据长度（累计值）。       |
| `_b_head_parse`     | 标记是否已解析完消息头部（`false`表示正在解析头部）。        |
| `_recv_head_node`   | 存储消息头部的节点（固定大小 `HEAD_LENGTH`，通常为 2 字节的 `short`）。 |
| `_recv_msg_node`    | 存储消息体的节点（长度由头部字段决定）。                     |

**注意：**

**每次进入 `HandleRead`时，`copy_len`确实会被初始化为 0**。但这并不影响它的正确性，因为：

1. **`copy_len`的作用是跟踪当前数据块 (`_data`) 中已处理的字节数**。
2. 每次 `HandleRead`被调用时，`_data`都是全新的（通过 `async_read_some`填充），所以 `copy_len`从 0 开始是合理的。
3. **在 `while`循环中**，`copy_len`会动态累加，确保正确处理粘包/拆包后的数据偏移。

## **2.逻辑流程图**

```
开始 HandleRead
│
├─ 如果 (!_b_head_parse) → 正在解析头部：
│   ├─ 如果 (当前数据 + 已接收头部数据 < HEAD_LENGTH) → 数据不足：
│   │   ├─ 将数据拼接到 _recv_head_node
│   │   └─ 继续读取剩余数据
│   │
│   └─ 如果 (数据足够解析头部)：
│       ├─ 解析消息长度 data_len
│       ├─ 检查 data_len 是否合法
│       ├─ 创建 _recv_msg_node 准备接收消息体
│       ├─ 如果 (剩余数据 < data_len) → 消息体未收全：
│       │   ├─ 将部分数据存入 _recv_msg_node
│       │   └─ 继续读取剩余数据
│       │
│       └─ 如果 (剩余数据 ≥ data_len) → 消息体完整：
│           ├─ 复制完整消息体到 _recv_msg_node
│           ├─ 处理消息（如调用 Send 回显）
│           └─ 继续处理缓冲区剩余数据
│
└─ 如果 (_b_head_parse) → 正在解析消息体：
    ├─ 计算剩余未接收的消息体长度 remain_msg
    ├─ 如果 (剩余数据 < remain_msg) → 消息体未收全：
    │   ├─ 将部分数据存入 _recv_msg_node
    │   └─ 继续读取剩余数据
    │
    └─ 如果 (剩余数据 ≥ remain_msg) → 消息体完整：
        ├─ 复制完整消息体到 _recv_msg_node
        ├─ 处理消息（如调用 Send 回显）
        └─ 继续处理缓冲区剩余数据
```

## **3.重点代码段解析**

###  **(1) 整体逻辑**

- **输入**：`error`：读取是否出错（如连接断开）。`bytes_transferred`：本次 `async_read_some`实际读取的字节数。`shared_self`：`shared_ptr`形式的 `this`，用于延长对象生命周期。
- **输出**：解析完整的消息后，调用 `Send()`回显数据（或触发业务逻辑）。如果出错，关闭会话并通知服务器清理。

### **(2)  错误处理**

```c++
if (!error) {
    // 正常处理数据
} else {
    std::cout << "handle read failed, error is " << error.what() << endl;
    Close();
    _server->ClearSession(_uuid);
}
```

### **(3) 数据解析主循环**

```c++
int copy_len = 0;
while (bytes_transferred > 0) {
    // 处理头部或消息体
}
```

- `copy_len`记录已从 `_data`缓冲区复制的字节数。
- 循环处理 `bytes_transferred`，直到所有数据被解析。

### **(4) 头部解析（`!_b_head_parse`）**

#### **情况 1：收到的数据不足头部大小**

```c++
if (bytes_transferred + _recv_head_node->_cur_len < HEAD_LENGTH) {
    // 将本次数据拼接到头部缓冲区
    memcpy(_recv_head_node->_data + _recv_head_node->_cur_len, _data + copy_len, bytes_transferred);
    _recv_head_node->_cur_len += bytes_transferred;
    
    // 清空缓冲区并继续读取
    ::memset(_data, 0, MAX_LENGTH);
    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), 
        std::bind(&CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self));
    return;
}
```

- 如果当前数据 + 已接收的头部数据仍不足 `HEAD_LENGTH`，将数据暂存到 `_recv_head_node`。
- 清空 `_data`，继续异步读取剩余数据。

#### **情况 2：收到的数据足够解析头部**

```c++
// 计算头部剩余未复制的长度
// 计算还需要多少字节才能补全完整的消息头部。
// 例如：HEAD_LENGTH=2，已接收 _cur_len=1，则 head_remain=1。
int head_remain = HEAD_LENGTH - _recv_head_node->_cur_len;
// 将本次收到的数据中属于头部的部分（head_remain字节）复制到 _recv_head_node。
memcpy(_recv_head_node->_data + _recv_head_node->_cur_len, _data + copy_len, head_remain);

// 更新已处理的数据位置,确保后续代码知道哪些数据已经处理过，哪些仍需处理
copy_len += head_remain;       // 已处理的数据偏移量增加
bytes_transferred -= head_remain; // 剩余未处理的数据长度减少

// 解析头部中的消息长度（假设是 2 字节的 short）
short data_len = 0;
memcpy(&data_len, _recv_head_node->_data, HEAD_LENGTH);

// 检查长度合法性
if (data_len > MAX_LENGTH) {
    std::cout << "invalid data length is " << data_len << endl;
    _server->ClearSession(_uuid);
    return;
}

// 创建消息体节点
_recv_msg_node = make_shared<MsgNode>(data_len);
```

- 补全头部数据，解析出消息长度 `data_len`。
- 如果 `data_len`超过 `MAX_LENGTH`，视为非法数据，关闭会话。
- 初始化 `_recv_msg_node`，准备接收消息体。

#### **情况 3：消息体未收全**

```c++
// 本次接收的数据不足以构成完整的消息体（如需要 5字节，但只收到 3字节）
if (bytes_transferred < data_len) {
    // 将部分消息体存入 _recv_msg_node
    memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, bytes_transferred);
    _recv_msg_node->_cur_len += bytes_transferred;
    
    // 继续读取剩余数据
    ::memset(_data, 0, MAX_LENGTH);
    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), 
        std::bind(&CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self));
    _b_head_parse = true;  // 标记头部已处理
    return;
}
```

- 如果剩余数据不足 `data_len`，暂存到 `_recv_msg_node`。
- 继续异步读取剩余数据，并标记 `_b_head_parse = true`（下次处理消息体）。

#### **情况 4：消息体已完整**

```c++
// 复制完整的消息体
// 将本次收到的完整消息体数据从_data缓冲区复制到_recv_msg_node->_data中
memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, data_len);

// 更新长度和偏移量
_recv_msg_node->_cur_len += data_len;  // 更新已接收的消息体长度
copy_len += data_len;                 // 更新已处理的原始数据偏移量
bytes_transferred -= data_len;        // 减少剩余未处理的数据长度

// 处理消息（如回显）
_recv_msg_node->_data[_recv_msg_node->_total_len] = '\0';
cout << "receive data is " << _recv_msg_node->_data << endl;
Send(_recv_msg_node->_data, _recv_msg_node->_total_len);

// 重置状态，准备处理下一条消息
_b_head_parse = false;
_recv_head_node->Clear();
```

- 复制完整的消息体到 `_recv_msg_node`。
- 调用 `Send()`回显数据（实际项目中可能触发业务逻辑）。
- 重置 `_b_head_parse`和 `_recv_head_node`，准备处理下一条消息。

### **(5)  消息体解析（`_b_head_parse == true`）**

#### **情况 1：剩余数据不足消息体**

```c++
// 计算剩余未接收的消息体长度
int remain_msg = _recv_msg_node->_total_len - _recv_msg_node->_cur_len;

// 检查本次接收的数据是否不足以补全消息体
// 如果本次读取的数据量不足以补全剩余消息体（bytes_transferred < remain_msg），进入分支
if (bytes_transferred < remain_msg) {
    // 将本次数据暂存到消息体缓冲区
    memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, bytes_transferred);
    
    // 更新已接收的消息体长度
    _recv_msg_node->_cur_len += bytes_transferred;
    
    // 清空接收缓冲区并继续异步读取
    ::memset(_data, 0, MAX_LENGTH);
    _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH), 
        std::bind(&CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self));
    
    // 直接返回，等待下次数据到达
    return;
}
```

+ 如果剩余数据不足以补全消息体，暂存数据并继续异步读取。

#### **情况 2：剩余数据补全消息体**

```c++
// 将当前接收缓冲区中剩余的消息体数据（长度为 remain_msg）拷贝到消息节点 _recv_msg_node 中
memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, remain_msg);

// 更新消息节点中已接收数据的长度（增加 remain_msg 字节）
_recv_msg_node->_cur_len += remain_msg; 
// 减少待处理的字节数（从 bytes_transferred 中扣除已处理的 remain_msg 字节）
bytes_transferred -= remain_msg;
// 更新已从接收缓冲区 _data 中复制的数据长度（增加 remain_msg 字节）
copy_len += remain_msg;

// 在消息数据的末尾添加字符串结束符 '\0'，方便后续作为字符串处理
_recv_msg_node->_data[_recv_msg_node->_total_len] = '\0';
cout << "receive data is " << _recv_msg_node->_data << endl;

// 回显数据（或触发业务逻辑）
Send(_recv_msg_node->_data, _recv_msg_node->_total_len);

// 重置状态，处理剩余数据
// _b_head_parse = false 表示下一条消息需要先解析头部
_b_head_parse = false;

// 清空头部接收节点，为接收下一条消息的头部做准备
// 这个操作会将 _recv_head_node 的 _cur_len 重置为 0 等
_recv_head_node->Clear();
```

+ 补全消息体后，回显数据并重置状态。

### **(6)  继续处理剩余数据**

```c++
// 检查是否已经处理完所有接收到的数据（bytes_transferred <= 0）
if (bytes_transferred <= 0) {
    // 清空接收缓冲区_data，准备接收新的数据
    // MAX_LENGTH是缓冲区的最大长度，memset将所有字节置为0
    ::memset(_data, 0, MAX_LENGTH);
    
    // 发起异步读取操作，继续从socket接收数据
    _socket.async_read_some(
        boost::asio::buffer(_data, MAX_LENGTH),
        std::bind(&CSession::HandleRead, 
                 this, 
                 std::placeholders::_1, 
                 std::placeholders::_2, 
                 shared_self())
    );
    
    // 直接返回，等待异步操作完成
    // 当有新数据到达时，HandleRead会被再次调用
    return;
}
```

+ 如果所有数据已处理完，清空缓冲区并继续异步读取。

## 4.优化代码

```c++
void CSession::HandleRead(const boost::system::error_code& error, size_t bytes_transferred, std::shared_ptr<CSession> shared_self) {
    if (!error) {
        int copy_len = 0;
        while (bytes_transferred > 0) {
            if (!_b_head_parse) {
                // 1. 处理头部未完整的情况
                if (bytes_transferred + _recv_head_node->_cur_len < HEAD_LENGTH) {
                    memcpy(_recv_head_node->_data + _recv_head_node->_cur_len, _data + copy_len, bytes_transferred);
                    _recv_head_node->_cur_len += bytes_transferred;
                    break;  // 头部未完整，直接退出循环，等待下次数据
                }

                // 2. 头部已完整，解析消息长度
                int head_remain = HEAD_LENGTH - _recv_head_node->_cur_len;
                memcpy(_recv_head_node->_data + _recv_head_node->_cur_len, _data + copy_len, head_remain);
                copy_len += head_remain;
                bytes_transferred -= head_remain;

                short data_len = 0;
                memcpy(&data_len, _recv_head_node->_data, HEAD_LENGTH);
                if (data_len > MAX_LENGTH) {
                    std::cout << "invalid data length: " << data_len << std::endl;
                    _server->ClearSession(_uuid);
                    return;
                }

                _recv_msg_node = make_shared<MsgNode>(data_len);
                _b_head_parse = true;  // 标记头部已解析，后续直接处理消息体
                continue;  // 继续处理剩余数据（可能是消息体的部分）
            }

            // 3. 处理消息体（头部已解析）
            int remain_msg = _recv_msg_node->_total_len - _recv_msg_node->_cur_len;
            if (bytes_transferred < remain_msg) {
                memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, bytes_transferred);
                _recv_msg_node->_cur_len += bytes_transferred;
                break;  // 消息体未完整，等待下次数据
            }

            // 4. 消息体已完整
            memcpy(_recv_msg_node->_data + _recv_msg_node->_cur_len, _data + copy_len, remain_msg);
            _recv_msg_node->_cur_len += remain_msg;
            copy_len += remain_msg;
            bytes_transferred -= remain_msg;
            _recv_msg_node->_data[_recv_msg_node->_total_len] = '\0';
            std::cout << "receive data: " << _recv_msg_node->_data << std::endl;

            // 5. 处理完整消息（例如回显或业务逻辑）
            Send(_recv_msg_node->_data, _recv_msg_node->_total_len);

            // 6. 重置状态，准备处理下一条消息
            _b_head_parse = false;
            _recv_head_node->Clear();
        }

        // 7. 继续异步读取
        ::memset(_data, 0, MAX_LENGTH);
        _socket.async_read_some(boost::asio::buffer(_data, MAX_LENGTH),
            std::bind(&CSession::HandleRead, this, std::placeholders::_1, std::placeholders::_2, shared_self));
    } else {
        std::cout << "handle read failed: " << error.what() << std::endl;
        Close();
        _server->ClearSession(_uuid);
    }
}
```

